### 排序问题解答
根据数据的特征选择合适的算法：
- 有没有可能包含大量重复的元素？ 如果有，三路快排是更好的选择，否则基本快排
- 是否近乎有序？如果是，选择插入排序
- 是否数据的取值范围十分有限，比如学生成绩？如果是，选择计数排序
- 是否需要稳定一点的排序？如果是，选择归并排序
- 如果的存储结是怎样的？如果是链表，选择归并排序;顺序表选择快排
- 数据是否可以完全存入内存？如果不能，选择外排序
- 如果数据量比较小，选择插入排序

### 数据规模的概念
如果在 1s 内解决问题：
- O(n^2) 的算法可处理大约 10^4 级别的数据
- O(nlog) 的算法可处理大约 10^7 级别的数据
- O(n) 的算法可处理大约 10^8 级别的数据
- 


### 二叉树性质 
- 性质1: 在二叉树的第i层上至多有2^(i-1)个结点（i>0）
- 性质2: 深度为k的二叉树至多有2^k - 1个结点（k>0）
- 性质3: 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;
- 性质4:具有n个结点的完全二叉树的深度必为 log2(n+1)
- 性质5:对完全二叉树，若从上至下、从左至右编号，则编号为i的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）


### 二叉树实现
```

class Node(object):
    """节点类"""
    def __init__(self, elem=-1, lchild=None,rchild=None):
        self.elem = elem
        self.lchild = lchild
        self.rchild = rchild


class Tree(object):
    """树类"""
    def __init__(self, root=None):
        self.root = root

    def add(self, elem):
        """添加节点"""
        node = Node(elem)
        if self.root == None:
            self.root = node
        else:
            queue = []
            queue.append(self.root)
            # 对已有节点进行层次遍历
            while queue:
                # 弹出第一个元素
                cur = queue.pop(0)
                if cur.lchild == None:
                    cur.lchild = node
                    return
                elif cur.rchild == Node:
                    cur.rchild = node
                    return
                else:
                    # 如果左右子树都不为空，加入队列继续判断
                    queue.append(cur.lchild)
                    queue.append(cur.rchild)

    # 深度优先遍历一般用递归，一般情况下，能有递归实现的会转换为用堆栈实现
    def preorder(self,root):
        """先序遍历 根结点 ---> 左子树 ---> 右子树"""
        if root == Node:
            return
        print(root.item)
        self.preorder(root.lchild)
        self.preorder(root.rchild)

    def inorder(self, root):
        """递归实现中序遍历 左子树---> 根结点 ---> 右子树"""
        if root == None:
            return
        self.inorder(root.lchild)
        print(root.elem)
        self.inorder(root.rchild)

    def postorder(self, root):
        """递归实现后续遍历 左子树 ---> 右子树 ---> 根结点"""
        if root == None:
            return
        self.postorder(root.lchild)
        self.postorder(root.rchild)
        print(root.elem)

    def breadth_travel(self, root):
        """利用队列实现树的层次遍历"""
        if root == None:
            return
        queue = []
        queue.append(root)
        while queue:
            node = queue.pop(0)
            print(node.elem)
            if node.lchild != None:
                queue.append(node.lchild)
            if node.rchild != None:
                queue.append(node.rchild)
```

### 二分查找

```

def search(nums, n):
    """
    二分搜索（Binary search）是一项用于搜索已排序数据的技术。它通过选出数据的中项，与目标数值相比较。
    """
    l = 0
    r = len(nums) - 1

    print(__search1(nums, l, r, n))
    print(__search2(nums, l, r, n))


def __search1(nums, l, r, n):
    """
    循环实现二分查找
    """

    while l <= r:
        mid = l + (r - l) // 2
        v = nums[mid]
        if v == n:
            return mid
        elif v > n:
            r = mid - 1
        else:
            l = mid + 1

    return -1


def __search2(nums, l, r, n):
    """
    递归实现二分查找
    """
    mid = l + (r - l) // 2
    v = nums[mid]
    if l <= r:
        if v == n:
            return mid
        elif v > n:
            return __search2(nums, l, mid - 1, n)
        else:
            return __search2(nums, mid + 1, r, n)
    else:
        return -1

```

### 排序

#### 三路快排
```
# 三路快排


def quick_sort(nums, size):

    _quicksort(nums, 0, size-1)


def _quicksort(nums, l, r):

    if l >= r:
        return

    lt, gt = _partition(nums, l, r)
    _quicksort(nums, l, lt-1)
    _quicksort(nums, gt, r)


def _partition(nums, l, r):
    """
        三路快排，从第一个和最后一个元素同时开始找出 <= v 或 >= v 的元素
    """
    # 随机选出基准元素并与第一个元素交换
    rand_index = random.randint(l, r)
    nums[rand_index], nums[l] = nums[l], nums[rand_index]

    v = nums[l]
    lt = l
    gt = r
    i = l + 1

    while i <= gt:
        if nums[i] > v:
            nums[gt], nums[i] = nums[i], nums[gt]
            gt -= 1
        elif nums[i] < v:
            lt += 1
            nums[lt], nums[i] = nums[i], nums[lt]
            i += 1
        else:
            i += 1

    nums[l], nums[lt] = nums[lt], nums[l]

    return lt, gt

```

#### 冒泡
```
def sort(nums):
    for i in range(len(nums) - 1):
        for j in range(len(nums)-1 - i):
            if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]


def sort2(nums):
    exchange = False
    for i in range(len(nums)-1, 0, -1):
        for j in range(i):
            if nums[j] > nums[j+1]:
                nums[j], nums[j+1] = nums[j+1], nums[j]
                exchange = True
        if not exchange:
            break

```
#### 归并
```
def merge_sort(alist):
    if len(alist) <= 1:
        return alist
    # 二分分解
    num = len(alist)//2
    left = merge_sort(alist[:num])
    right = merge_sort(alist[num:])
    # 合并
    return merge(left, right)


def merge(left, right):
    '''合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'''
    #left与right的下标指针
    l, r = 0, 0
    result = []
    while l<len(left) and r<len(right):
        if left[l] < right[r]:
            result.append(left[l])
            l += 1
        else:
            result.append(right[r])
            r += 1
    result += left[l:]
    result += right[r:]
    return result

```

#### 插入
```
def sort(nums):
    """
    插入排序，
    :param nums:
    :return:
    """
    size = len(nums)
    for i in range(1, size):
        for j in range(i, 0, -1):
            if nums[j] < nums[j-1]:
                nums[j], nums[j-1] = nums[j-1], nums[j]


def sort2(nums):
    """
    优化，减少交换操作
    :param nums:
    :return:
    """
    size = len(nums)
    for i in range(1, size):
        temp = nums[i]
        index = i
        while nums[index-1] > temp and index > 0:
            nums[index] = nums[index-1]
            index -= 1

        nums[index] = temp

```

#### 选择

```
def select_sort(arr, size):
    """选择排序，每个元素与他后面最小的元素交换位置"""
    for i in range(size - 1):      # 最后一个元素不需要再遍历
        min_index = i
        for j in range(i+1, size):
            if arr[j] < arr[min_index]:  # 找出最小的元素
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]  # 将当前位置与最小元素交换


def advance_select_sort(arr, size):
    """优化选择排序,在每一轮排序中,找出当前未处理元素的最大值和最小值"""
    for i in range(size - 1):
        left = min_index = i
        right = max_index = size - 1 - i

        if left >= right:
            return

        if arr[left] > arr[right]:  # 每次遍历要先保证左边的值大于右边的值
            arr[left], arr[right] = arr[left], arr[right]

        for j in range(left + 1, right):
            if arr[j] < arr[min_index]:  # 找出最小值
                min_index = j
            if arr[j] > arr[max_index]:  # 找出最大值
                max_index = j

        arr[left], arr[min_index] = arr[min_index], arr[left]  # 未排序元素中的最小值与未排序的最左端交换
        arr[right], arr[max_index] = arr[max_index], arr[right]  # 未排序元素中的最大值与未排序的最右端交换

```

### 斐波那契数列
```
def fib1(n):
    i, a, b = 0, 0, 1

    while i < n:
        a, b = b, a+b
        i += 1

    return a


def fib2(n):
    if n <= 2:
        if n <= 0:
            return
        else:
            return 1
    res = fib2(n-1) + fib2(n-2)
    return res


def fib3(a, b, n):
    if n <= 2:
        if n <= 0:
            return
        else:
            return b
    return fib3(b, a + b, n - 1)


if __name__ == '__main__':
    # 0 1 1 2 3
    print(fib1(6))
    print(fib2(6))
    print(fib3(1, 1, 6))

```

```
// 斐波那契
func fib(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 || n == 2 {
		return 1
	}

	return fib(n-1) + fib(n-2)
}

// 斐波那契循环

func fib2(n int) int {
	i, a, b := 0, 0, 1

	for i < n {
		a, b = b, a + b
		i ++
	}
	return a
}
```

### 重建二叉树
```
"""

要求：用前序和中序遍历结果构建二叉树，遍历结果中不包含重复值

思路：前序的第一个元素是根结点的值，在中序中找到该值，中序中该值的左边的元素是根结点的左子树，右边是右子树，然后递归的处理左边和右边
"""
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def construct_tree(pre=None, tin=None):
    """构建二叉树"""
    if not pre or not tin:
        return None
    # 根节点
    root = TreeNode(pre.pop(0))
    # 根节点在中序排列中的索引
    index = tin.index(root.val)
    # 左节点
    root.left = construct_tree(pre, tin[:index])
    # 右节点
    root.right = construct_tree(pre, tin[index + 1:])
    return root
```
### 查找二维数组
```
"""
题目：二维数组中的查找
描述：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
思路：描述中提到是有序数组，所以很容易想到二分查找，但其实更好的做法是从矩阵的左下角或右上角开始，通过与目标函数比较大小，可以找出一条通往目标值的唯一通道
"""


class Solution:

    def Find(self, target, array):
        rows, cols = len(array), len(array[0])
        # 找到矩阵的右上角
        x, y = 0, cols - 1
        # 从右上角开始找目标值
        while x < rows and y >= 0:
            if array[x][y] == target:
                return True
            elif array[x][y] < target:
                x += 1
            else:
                y -= 1
        return False
```

#### 判断链表无环
```
def hasCycle(head):

        if head == None or head.next == None: # 判断是否为空
            return False
        slow = fast = head
        while fast and fast.next:
            slow = slow.next  # 一次走一步
            fast = fast.next.next # 一次走两步
            if slow == fast:
                return True
        return False
```