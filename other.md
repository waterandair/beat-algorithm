#### 什么是哈希，特点？冲突
利用hash函数，把key转换成一个整数，整数对一个数组数组长度取模运行，得出的值就是value在数组中的下标，就可以高速存储。查询的时候再通过hash函数计算出key的位置，就可以高速访问。

是结合了数组查询快和链表的插入删除快的特点形成的。

##### 解决hash 冲突
- 开发定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）
- 再哈希法， 多个 hash 函数，不易产生聚集，但增加了计算时间
- 链地址法，用一个hash值的vlaue 放到一个 链表中
- 建立一个公共溢出区，凡是和基本表发生冲突的元素，一律填入溢出表。 java中hashmap采用的是链地址法

#### topk 问题
1. 先循环，用Hash表统计每个Query出现的次数，O（N）；
2. 然后第二步、采用堆数据结构找出Top 10，N*O（logK）。所以，我们最终的时间复杂度是：O（N） + N’*O（logK）。
3. 第二步或者：建立一个10个长度的数组，循环依次找出前十大小的结果


对于大数据的 topk 问题，使用 spark，使用wordcount 得出每个key的数量，然后可以反过来，直接sort，然后take取前k。
但还有更好的做法，使用最小堆（优先级队列）。对 wordcount 进行分区，每个分区内建立一个优先级队列topk的优先级队列，然后在外部再新建一个 topk 的优先级队列，然后把刚刚计算的结果入队，就可以求出topk。

#### url去重

布隆过滤器，redis实现，是一个位数组和多个hash函数，进来一个key，用多个hash函数计算出多个位置，把多个位置设置成1，
判断某个值是否存在，就用多个hash函数计算出值并查看这些位置上是否为1，如果为1的话，就判断为存在。

正是因为这种判断方式，所以当位数组比较稀疏的时候正确绿会比较大，反之则容易误判

#### 进程和线程
进程是os分配资源的基本单位，线程是独立运行和独立调度的基本单位。进程与进程之间是隔离独立的，各自有各自的堆栈和数据区域，一个线程下最少有一个线程，多个线程共享所在进程的资源。  

因为进程间是独立的，所以一个进程崩溃了不会对其他进程产生影响，但进程下所有的线程都会崩溃。所以多进程要比多线程更健壮一些，但是多进程消耗资源比线程大得多。对于一些需要共享变量的并发操作，只能有多线程。


#### 进程间通信的方式

- 管道 pipe：半双工通信，数据只能单向流动，而且只能在父子进程中使用
- 有名管道 named pipe: 半双工，允许无亲缘关系的进程使用
- 信号量:
- 消息队列
- 信号 signal
- 共享内存：最快，配合信号量
- 套接字socket: 用于不在同一台机器上的进程通信


#### 线程通信
- 锁机制：排它锁，共享锁，乐观锁
- 信号
线程中的通信主要用于数据同步，进程中主要用于通信

#### http协议
应用层-短连接-无状态

状态码：
- 200：成功
- 302：重定向
- 304：访问了缓存
- 401：权限不足
- 403：资源禁止访问
- 404：客户端错误
- 500： 服务器端错误
- 502：请求无法及时发送到后端

http 协议格式：
请求行-请求头部-空行-请求体
状态行-响应头-空行-响应体
#### tcp

三次握手：

- 客户端向服务器端发送 syn 请求
- 服务端收到 syn 后加上一个 ack 响应 返回给客户端
- 客户端收到 服务端的 syn+ack 进入 established 状态，并发送 ack 给 服务端
- 服务端收到 ack 后 也进入 established 状态

传输数据：
- 客户端向服务器端发送 data， 服务端向客户端返回 ack 响应
- 如果服务端迟迟不回应，客户端会重新发送，同样的可能会出现服务端需要去重的情况
- 客户端服务端之间可以批量发送数据，发送和接收的速率就是 tcp 时间窗口

四次挥手：
- 客户端发送fin请求
- 服务端返回ack， 并进入 close_wait 状态
- 服务端最后一次发送 fin 请求，
- 客户端收到后 返回 ack 请求，进入time_close 状态，通常 4 分钟
- 服务端接收到响应后断开连接


#### udp
tcp 是面向连接的，udp无连接。tcp可靠，udp不可靠，但udp效率高
#### https 过程
- 客户端向服务端发出请求，走 443 端口，将自己支持的hash算法发送给网站
- 服务器返回证书，包括自己的身份信息，公钥等信息并选出 hash 算法
- 客户端收到证书，验证证书的合法性，合法的话，会生成一串随机密码，并用公钥对随机码加密，
- 客户端将握手信息用随机密码加密，并计算出握手信息的hash值，将所有生成的数据发送给服务器端
- 服务器端接收到信息，用私钥解密出客户端的随机密码，然后就可以解密出随机密码加密的握手信息，并用相同的hash算法验证是否一致
- 服务端使用随机码加密握手信息，发送给客户端
- 客户端解密握手信息，hash验证一致后握手成功


#### json web token
- 客户端使用用户名和密码登录
- 服务端收到请求后会去验证用户名和密码，如果成功，就签发一个token返回客户端
- 客户端收到请求后会将 token 缓存起来，放到 cookie或local storage，每次请求都带 token
- 服务端验证token

token 组成：
- header
```
{
  "typ": "JWT",
  "alg": "HS256"
}
```
- payload
```
{
 "id": 2,
 "username": "kong",
 "nbf": 1527931805, # 生效时间
 "iat": 1527931805  # 签发时间
}
```

- signature
```
用 base64 对 header 和 payload 编码，用 secret 对编码加密
```
#### websocket
websocket HTML5支持的是全双工的通信协议，http协议是单工的，所以以前常常使用轮询模拟双工。

- 客户端通过 http 请求与 websocket 服务端协商服务升级，升级后，后续数据传输就按照 websocket 协议进行
```
GET / HTTP/1.1
Host: localhost:8080
Origin: http://127.0.0.1:3000
Connection: Upgrade             # 表示要升级协议
Upgrade: websocket              # 表示要升级到websocket协议
Sec-WebSocket-Version: 13       # 表示websocket的版本
Sec-WebSocket-Key: w4v7O6xFTi36lq3RNcgctw==  # 验证连接
```

- 服务端响应服务升级
```
HTTP/1.1 101 Switching Protocols
Connection:Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU=
```


