### sql 语句优化的步骤
对几个状态心中有数， connects， com_select/update/insert/delete,slow_queries等等，找到执行较慢的sql后，可以用 explain 分析sql的执行计划，可以获得sql的查询类型，全表扫描是最耗性能的，对于这样的sql一定要试着优化，也可以获取到sql使用索引的情况，比如可能使到的索引，实际使用的索引，使用到的索引字段的长度，了解了这些就可以针对性的进行索引优化。执行完 explain 后 执行 show warnings， 可以看到sql 真正被执行之前优化器做了哪些 sql 改写，进一步了解sql实际的执行方式。

进一步优化的话，可以查看 performance_schema 中的数据，也可以使用 trace 分析优化器如何选择执行计划 

### sql 一些原则
#### 字段
- 尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED；
- VARCHAR的长度只分配真正需要的空间；
- 使用枚举或整数代替字符串类型；
- 尽量使用TIMESTAMP而非DATETIME；
- 单表不要有太多字段，建议在20以内；
- 避免使用 NULL 字段，很难查询优化且占用额外索引空间；
- 用整型来存IP。

#### 索引
- 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描；
- 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描；
- 值分布很稀少的字段不适合建索引，例如“性别”这种只有两三个值的字段；
- 字符字段只建前缀索引；
- 字符字段最好不要做主键；
- 不用外键，由程序保证约束；
- 尽量不用UNIQUE，由程序保证约束；
- 使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引。

#### 查询SQL
- 可通过开启慢查询日志来找出较慢的SQL；
- 不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边；
- sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库；
- 不用SELECT *；
- OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，IN的个数建议控制在200以内；
- 不用函数和触发器，在应用程序实现；
- 避免%xxx式查询；
- 少用JOIN；
- 使用同类型进行比较，比如用'123'和'123'比，123和123比；
- 尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描；
- 对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5；
- 列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大。


### mysql 日志
mysql 有四种日志，错误日志，查询日志，慢查询日志，二进制日志。  
- 错误日志记录了mysql启动停止和运行中出现的异常错误的相关信息
- 查询日志记录了客户端所有的查询语句，可以存在文件或表中，一般不开启
- 慢查询日志记录了所有执行时间超过 long_query_time 的 sql 语句
- binlog 记录了修改操作的过程，通常用来做主从复制和数据恢复
- 中继日志：主从同步，从库需要把主库传递过来的日志，记录到自己的 relay log 里面


### mysql 锁机制
mysql 有表级锁和行级锁,mysiam使用表级锁，innodb 默认使用行级锁，行级锁开销大，加锁慢，会出现死锁  

myisam 的表级锁有两种，一种是共享读锁，一种是独占写锁。这样就造成，读操作不会阻塞其他读请求，但会阻塞写请求。写操作会阻塞其他读写请求。myisam加锁是自动的给涉及到的表加锁。myisam的写操作优先级高，当写操作频繁的时候，会使查询操作阻塞，所以myisam 不适合有大量写操作的应用。  

innodb 锁，  
- 共享锁（行）： 允许事务读一行，阻止其他事务获取该行的排它锁
- 排它锁（行）： 允许获取某行的排它锁，进行更新，阻止其他事务获取相同行的共享锁和排他锁
- 意向共享锁(表)： 
- 意向排它锁(表)：  

排它锁和两种意向锁自动加，select 不自动加锁。对没有使用索引的查询语句加锁，会对全部记录加锁，因为行锁是对索引加锁。

### mysql innodb 死锁
两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。  

session1对表a中id为1的行加排它锁，session2对表b中id为1的行加排它锁，之后，session1尝试获取表b中id为1的行的排它锁形成阻塞，session2尝试获取表a中id=1的排它锁，发生死锁。  

1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。

2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用分布式事务锁或者使用乐观锁

### mysql innodb 事务
并发事务存在的问题
- 更新丢失：多个事务更新某行，事务不知道其他事务的存在，最后的更新覆盖其他事务做的更新
- 脏读: 读出了未提交事务的修改
- 不可重复读:事务未提交前，两次相同的查询得到不同的结果集
- 幻读: 事务a查询id 1 没有，事务b插入id 1， 事务a插入id 1， 报错

更新丢失使用锁解决，脏读，不可重复读，幻读是数据库读一致性问题，需要数据库提供事务隔离机制
- 未提交读，什么问题都不能保证
- 已提交读，保证没有脏读
- 重复读，保证没有脏读，没有可重复读
- 序列化，保证没有任何问题

### 悲观锁和乐观锁
悲观锁就是认为数据一定会被其他请求修改，所以以偶开始就锁定当前数据不允许其他请读写，数据库自带的锁就是典型的悲观锁。  

乐观锁，认为自己在处理数据的时候不会被别的请求干扰，所以不会上锁，但提交更新的时候会根据版本号判断有没有被更改，乐观锁适合读多写少的应用，可以提高吞吐量（cas原则 compare and set）

### mysql 索引优化（B+Tree平衡树）

聚簇索引 innodb 索引的叶节点指向数据，查询数据少时，无须回行，不规则插入时频繁也分裂  
非聚簇索引 muyisam 索引中的姐姐点指向数据的引用  

主键索引 primary key()  主键约束，不能重复，不能为null，不能给索引命名，一个表只能有一个

唯一索引 unique name index('name') 唯一约束，不能重复  

普通索引 index name ('name') 对关键字没要求  

全文索引 fulltext index name ('name') 关键字来源是字段中提取的特别关键字  

多个字段组成的索引称为复合索引  

列独立，不能在表达式中，左前缀，like 左边不能用通配符，复合索引由左到右生效。


### mysql 分区

- key 分区  ，对主键字段取余 partition by key (id) partitions 5;
- hash 分区，基于给定的个数，把数据分配到不同的分区 partition by hash (month(birthday)) patitions 12; 
- range 分区，基于一个给定的连续区间范围，把数据分配到不同的分区 
- list 分区，类似 range 分区，区别在 list 分区是几区枚举出的值列表分区，range 是给定连续区间范围分区
- clumns 分区，支持整数，日期，字符串，可以细分为 range columns 分区和 list columns 分区
- 子分区

### mysql 备份
全量备份和增量备份，全备份的优点是备份保持最新备份，恢复的时候可以花费更少的时间；缺点是如果数据量大，将会花费很多的时间，并对系统造成较长时间的压力。增量备份相反，只需要备份每天的增量日志，备份时间少，对负载压力也小；缺点就是恢复的时候需要全备份加上次备份到故障前的所有日志，恢复时间长一些。

可以使用sql形式或文本形式的备份，都可以使用mysqldump工具，文本形式恢复时比sql形式快很多、

完全恢复需要借助mysqlbinlog工具恢复从上次备份到当前的sql日志，可以基于时间点或位置恢复

### 主从复制

- 从库 start salve，开启主从复制
- 从库使用主库授权的用户连接主库，并请求binlog
- 主库收到请求后，返回日志及新日志的位置
- 从库获取日志后，将日志写到中继日志文件末端，将新binlog文件名和位置记录到 master info中，
- 从库sql线程监控中继日志，一旦有更新，就把日志解析为sql并执行
- 主从实现同步


### （分库分表）某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么?他们的原理知道么？  

垂直分表： 减少单个表的字段，比如text  
垂直分库： 为了降低单节点的压力，把不同的业务相关的表，存到不同的库上，运行在多个mysql服务器上  
水平分表： 当单张表的数据根据某种规则(range,hash,日期，地域等等)切分到多个数据库，多个服务器  

分库分表后的问题：分布式事务，跨库join（两次查询），跨节点聚合、order by， group by 可以并行运行再汇总。  

id问题:  
- uuid, uuid简单，但很长，建立索引和索引查询都耗性能
- snowflake
















